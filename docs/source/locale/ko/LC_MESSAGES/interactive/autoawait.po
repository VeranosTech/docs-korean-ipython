# SOME DESCRIPTIVE TITLE.
# Copyright (C) The IPython Development Team
# This file is distributed under the same license as the IPython package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: IPython 7.3.0.dev\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-01-09 11:46+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../<rst_prolog>:4
msgid ""
"This documentation covers a development version of IPython. The "
"development version may differ significantly from the latest stable "
"release."
msgstr ""

#: ../../<rst_prolog>:9
msgid ""
"This documentation covers IPython versions 6.0 and higher. Beginning with"
" version 6.0, IPython stopped supporting compatibility with Python "
"versions lower than 3.3 including all versions of Python 2.7."
msgstr ""

#: ../../<rst_prolog>:13
msgid ""
"If you are looking for an IPython version compatible with Python 2.7, "
"please use the IPython 5.x LTS release and refer to its documentation "
"(LTS is the long term support release)."
msgstr ""

#: ../../source/interactive/autoawait.rst:4
msgid "Asynchronous in REPL: Autoawait"
msgstr ""

#: ../../source/interactive/autoawait.rst:8
msgid ""
"This feature is experimental and behavior can change between python and "
"IPython version without prior deprecation."
msgstr ""

#: ../../source/interactive/autoawait.rst:11
msgid ""
"Starting with IPython 7.0, and when user Python 3.6 and above, IPython "
"offer the ability to run asynchronous code from the REPL. Constructs "
"which are :exc:`SyntaxError` s in the Python REPL can be used seamlessly "
"in IPython."
msgstr ""

#: ../../source/interactive/autoawait.rst:15
msgid ""
"The examples given here are for terminal IPython, running async code in a"
" notebook interface or any other frontend using the Jupyter protocol "
"needs IPykernel version 5.0 or above. The details of how async code runs "
"in IPykernel will differ between IPython, IPykernel and their versions."
msgstr ""

#: ../../source/interactive/autoawait.rst:20
msgid ""
"When a supported library is used, IPython will automatically allow "
"Futures and Coroutines in the REPL to be ``await`` ed. This will happen "
"if an :ref:`await <await>` (or any other async constructs like async-"
"with, async-for) is use at top level scope, or if any structure valid "
"only in `async def "
"<https://docs.python.org/3/reference/compound_stmts.html#async-def>`_ "
"function context are present. For example, the following being a syntax "
"error in the Python REPL::"
msgstr ""

#: ../../source/interactive/autoawait.rst:39
msgid "Should behave as expected in the IPython REPL::"
msgstr ""

#: ../../source/interactive/autoawait.rst:59
msgid ""
"You can use the ``c.InteractiveShell.autoawait`` configuration option and"
" set it to :any:`False` to deactivate automatic wrapping of asynchronous "
"code. You can also use the :magic:`%autoawait` magic to toggle the "
"behavior at runtime::"
msgstr ""

#: ../../source/interactive/autoawait.rst:70
msgid ""
"By default IPython will assume integration with Python's provided "
":mod:`asyncio`, but integration with other libraries is provided. In "
"particular we provide experimental integration with the ``curio`` and "
"``trio`` library."
msgstr ""

#: ../../source/interactive/autoawait.rst:74
msgid ""
"You can switch current integration by using the "
"``c.InteractiveShell.loop_runner`` option or the ``autoawait <name "
"integration>`` magic."
msgstr ""

#: ../../source/interactive/autoawait.rst:78
msgid "For example::"
msgstr ""

#: ../../source/interactive/autoawait.rst:109
msgid ""
"In the above example, ``async with`` at top level scope is a syntax error"
" in Python."
msgstr ""

#: ../../source/interactive/autoawait.rst:112
msgid ""
"Using this mode can have unexpected consequences if used in interaction "
"with other features of IPython and various registered extensions. In "
"particular if you are a direct or indirect user of the AST transformers, "
"these may not apply to your code."
msgstr ""

#: ../../source/interactive/autoawait.rst:117
msgid ""
"When using command line IPython, the default loop (or runner) does not "
"process in the background, so top level asynchronous code must finish for"
" the REPL to allow you to enter more code. As with usual Python semantic,"
" the awaitables are started only when awaited for the first time. That is"
" to say, in first example, no network request is done between ``In[1]`` "
"and ``In[2]``."
msgstr ""

#: ../../source/interactive/autoawait.rst:125
msgid "Effects on IPython.embed()"
msgstr ""

#: ../../source/interactive/autoawait.rst:127
msgid ""
"IPython core being asynchronous, the use of ``IPython.embed()`` will now "
"require a loop to run. By default IPython will use a fake coroutine "
"runner which should allow ``IPython.embed()`` to be nested. Though this "
"will prevent usage of the :magic:`%autoawait` feature when using IPython "
"embed."
msgstr ""

#: ../../source/interactive/autoawait.rst:132
msgid ""
"You can set explicitly a coroutine runner for ``embed()`` if you desire "
"to run asynchronous code, the exact behavior is though undefined."
msgstr ""

#: ../../source/interactive/autoawait.rst:136
msgid "Effects on Magics"
msgstr ""

#: ../../source/interactive/autoawait.rst:138
#, python-format
msgid ""
"A couple of magics (``%%timeit``, ``%timeit``, ``%%time``, ``%%prun``) "
"have not yet been updated to work with asynchronous code and will raise "
"syntax errors when trying to use top-level ``await``. We welcome any "
"contribution to help fix those, and extra cases we haven't caught yet. We"
" hope for better support in Cor Python for top-level Async code."
msgstr ""

#: ../../source/interactive/autoawait.rst:145
msgid "Internals"
msgstr ""

#: ../../source/interactive/autoawait.rst:147
msgid ""
"As running asynchronous code is not supported in interactive REPL (as of "
"Python 3.7) we have to rely to a number of complex workaround and "
"heuristic to allow this to happen. It is interesting to understand how "
"this works in order to comprehend potential bugs, or provide a custom "
"runner."
msgstr ""

#: ../../source/interactive/autoawait.rst:152
msgid ""
"Among the many approaches that are at our disposition, we find only one "
"that suited out need. Under the hood we use the code object from a async-"
"def function and run it in global namespace after modifying it to not "
"create a new ``locals()`` scope::"
msgstr ""

#: ../../source/interactive/autoawait.rst:169
msgid ""
"The first thing you'll notice is that unlike classical ``exec``, there is"
" only one namespace. Second, user code runs in a function scope, and not "
"a module scope."
msgstr ""

#: ../../source/interactive/autoawait.rst:173
msgid ""
"On top of the above there are significant modification to the AST of "
"``function``, and ``loop_runner`` can be arbitrary complex. So there is a"
" significant overhead to this kind of code."
msgstr ""

#: ../../source/interactive/autoawait.rst:177
msgid ""
"By default the generated coroutine function will be consumed by Asyncio's"
" ``loop_runner = asyncio.get_evenloop().run_until_complete()`` method if "
"``async`` mode is deemed necessary, otherwise the coroutine will just be "
"exhausted in a simple runner. It is though possible to change the default"
" runner."
msgstr ""

#: ../../source/interactive/autoawait.rst:183
msgid ""
"A loop runner is a *synchronous*  function responsible from running a "
"coroutine object."
msgstr ""

#: ../../source/interactive/autoawait.rst:186
msgid ""
"The runner is responsible from ensuring that ``coroutine`` run to "
"completion, and should return the result of executing the coroutine. "
"Let's write a runner for ``trio`` that print a message when used as an "
"exercise, ``trio`` is special as it usually prefer to run a function "
"object and make a coroutine by itself, we can get around this limitation "
"by wrapping it in an async-def without parameters and passing this value "
"to ``trio``::"
msgstr ""

#: ../../source/interactive/autoawait.rst:203
msgid "We can set it up by passing it to ``%autoawait``::"
msgstr ""

#: ../../source/interactive/autoawait.rst:217
msgid ""
"Asynchronous programming in python (and in particular in the REPL) is "
"still a relatively young subject. We expect some code to not behave as "
"you expect, so feel free to contribute improvements to this codebase and "
"give us feedback."
msgstr ""

#: ../../source/interactive/autoawait.rst:221
msgid ""
"We invite you to thoroughly test this feature and report any unexpected "
"behavior as well as propose any improvement."
msgstr ""

#: ../../source/interactive/autoawait.rst:225
msgid "Using Autoawait in a notebook (IPykernel)"
msgstr ""

#: ../../source/interactive/autoawait.rst:227
msgid "Update ipykernel to version 5.0 or greater::"
msgstr ""

#: ../../source/interactive/autoawait.rst:233
#, python-format
msgid ""
"This should automatically enable :magic:`autoawait` integration. Unlike "
"terminal IPython, all code runs on ``asyncio`` eventloop, so creating a "
"loop by hand will not work, including with magics like :magic:`%run` or "
"other frameworks that create the eventloop themselves. In cases like "
"these you can try to use projects like `nest_asyncio "
"<https://github.com/erdewit/nest_asyncio>`_ and follow `this discussion "
"<https://github.com/jupyter/notebook/issues/3397#issuecomment-419386811>`_"
msgstr ""

#: ../../source/interactive/autoawait.rst:242
msgid "Difference between terminal IPython and IPykernel"
msgstr ""

#: ../../source/interactive/autoawait.rst:244
msgid ""
"The exact asynchronous code running behavior varies between Terminal "
"IPython and IPykernel. The root cause of this behavior is due to "
"IPykernel having a *persistent* `asyncio` loop running, while Terminal "
"IPython starts and stops a loop for each code block. This can lead to "
"surprising behavior in some case if you are used to manipulate asyncio "
"loop yourself, see for example :ghissue:`11303` for a longer discussion "
"but here are some of the astonishing cases."
msgstr ""

#: ../../source/interactive/autoawait.rst:252
msgid ""
"This behavior is an implementation detail, and should not be relied upon."
" It can change without warnings in future versions of IPython."
msgstr ""

#: ../../source/interactive/autoawait.rst:255
msgid ""
"In terminal IPython a loop is started for each code blocks only if there "
"is top level async code::"
msgstr ""

#: ../../source/interactive/autoawait.rst:270
msgid ""
"See that ``running`` is ``True`` only in the case were we ``await "
"sleep()``"
msgstr ""

#: ../../source/interactive/autoawait.rst:272
msgid "In a Notebook, with ipykernel the asyncio eventloop is always running::"
msgstr ""

#: ../../source/interactive/autoawait.rst:287
msgid ""
"In Terminal IPython background tasks are only processed while the "
"foreground task is running, if and only if the foreground task is async::"
msgstr ""

#: ../../source/interactive/autoawait.rst:316
msgid ""
"In a Notebook, QtConsole, or any other frontend using IPykernel, "
"background tasks should behave as expected."
msgstr ""

